module GslCore.Plugin.CoreOutput.CloneManager

open System.IO
open GslCore.Core.Types
open Amyris.Bio.utils
open GslCore
open GslCore.Constants

/// Clone manager formatted output
let dumpCM (outDir: string) (tag: string) (assemblies: DnaAssembly list) (primers: DivergedPrimerPair list list option) =

    let primers' =
        match primers with
        | None -> List.init assemblies.Length (fun _ -> None)
        | Some (p) -> p |> List.map (Some)

    let joint = List.zip assemblies primers'

    for a, primers in joint do
        let path =
            sprintf
                "%s.%d.cx5"
                tag
                (match a.Id with
                 | None -> failwith "ERROR: unassigned assembly id"
                 | Some (i) -> i)
            |> opj outDir

        printf "Writing CM5 output to dir=%s tag=%s path=%s\n" outDir tag (path.Replace(@"\", "/"))
        use outF = new StreamWriter(path)
        let w (s: string) = outF.Write(s)

        let molName = sprintf "%s_%d" tag a.Id.Value

        let molDescription =
            sprintf "GSL assembly %s_%d" tag a.Id.Value

        let molSize =
            a.DnaParts
            |> List.map (fun p -> p.Dna.Length)
            |> Seq.sum

        let primersInner =
            match primers with
            | None -> a.DnaParts |> List.map (fun _ -> None)
            | Some (p) -> p |> List.map (Some)

        let totSequence = a.Sequence()

        let deGT (x: string) =
            x.Replace(">", "&gt;").Replace("<", "&lt;")

        sprintf @"<?xml version=""1.0""?>
<!--SciEd XML 1 - DO NOT EDIT THIS FILE-->

<MOLECULE name=""%s"">
<FLAGS>1</FLAGS>
<SIZEBP>%d</SIZEBP>
<DESCRIPTION>%s </DESCRIPTION>" molName molSize molDescription
        |> w

        for p, dpp in List.zip a.DnaParts primersInner do
            let partName =
                if p.SliceName <> "" then p.SliceName
                elif p.Description <> "" then p.Description
                else (sprintf "part_%s" (Utils.ambId p.Id))

            let partType =
                match p.Type with
                | SliceType.Linker -> "Label"
                | SliceType.Inline -> "Label"
                | _ -> "Gene"

            let fr = (ZeroOffset.toOne p.DestinationFrom)
            let t = (ZeroOffset.toOne p.DestinationTo)

            sprintf @"<FEATURE name=""%s"">
                    <TYPE>%s</TYPE>
                    <STARTBP>%A</STARTBP>
                    <ENDBP>%A</ENDBP>
                    <COMPLEMENT>%s</COMPLEMENT>
                    </FEATURE>" (deGT partName) partType (if p.DestinationForward then fr else t) (if p.DestinationForward then t else fr)
                (if p.DestinationForward then "0" else "1")
            |> w

            w "\n"

            match dpp with
            | None -> ()
            | Some (Gap) -> () // Nothing to do here
            | Some (SandwichGap) -> () // Nothing to do here
            | Some (DivergedPrimerPair (dp)) ->
                // Diverged primer pair off this part, need to show them

                if dp.Reverse.Primer.Length <> 0 then
                    // Simple example, tail is part of the linker region.
                    // It might not span the entire region
                    // .......[XXXXXXXXXXXXXXXXXXX].........
                    //  <bbbbbbtttttttttttttttt????  (body and tail of primer)
                    //
                    // Complex example, a sandwich region sss might be part of the
                    // tail - need to find the longest prefix of the tail that is the
                    // sequence leading up to left end of the linker region
                    //..........[XXXXXXXXXXXXXXXXXXX].........
                    //<bbbbbbsssstttttttttttttttt????  (body and tail of primer)
                    let rec longestPrefix (n: int) =
                        if p.DestinationFrom + ((n - 1) * 1<ZeroOffset>)
                           >= totSequence.Length * 1<ZeroOffset> then
                            longestPrefix (n - 1)
                        else if dp.Reverse.Primer.[..n - 1].RevComp().arr = totSequence
                            .ToString()
                            .Substring(p.DestinationFrom / 1<ZeroOffset>, n)
                            .ToCharArray() then
                            n * 1<ZeroOffset>
                        else
                            longestPrefix (n - 1)

                    let prefix = longestPrefix (dp.Reverse.Primer.Length)

                    sprintf @"
                                <PRIMER name=""PR"">

                                <VERSION>1</VERSION>
                                <SEQHOMOL>%s</SEQHOMOL>
                                <BINDSITE>%A,1,0,%d,0,%d</BINDSITE>
                                <DESCRIPTION>PR</DESCRIPTION></PRIMER>
                                " (dp.Reverse.Primer.ToString())
                        // .......[XXXXXXXXXXXXXXXXXXX].........
                        //  <bbbbbbtttttttttttttttttttt  (body and tail of primer)
                        (ZeroOffset.toOne (* (dp.rev.tail.Length-1) * 1<ZeroOffset>  *) (p.DestinationFrom + prefix - 1<ZeroOffset>))  // from
                        dp.Reverse.Primer.Length  //length
                        dp.Reverse.Primer.Length
                    |> w

                    w "\n"

                if dp.Forward.Primer.Length <> 0 then
                    // simple example
                    //
                    // ............[XXXXXXXXXXX]...........
                    //              ttttttttttttbbbbbbbbbbb>> (tail/body)
                    //
                    // complex example  (see above)
                    // ............[XXXXXXXXXXX]...........
                    //               ?ttttttttttsssbbbbbbbbbbb>> (tail/sandwich/body)
                    let rec longestPrefixFwd (n: int) =
                        if p.DestinationTo - ((n - 1) * 1<ZeroOffset>) < 0<ZeroOffset> then
                            longestPrefixFwd (n - 1)
                        else if dp.Forward.Primer.[..n - 1].arr = totSequence
                            .str
                            .Substring((p.DestinationTo / 1<ZeroOffset>) - n + 1, n)
                            .ToCharArray() then
                            n * 1<ZeroOffset>
                        else
                            longestPrefixFwd (n - 1)

                    // TODOTODO - doesn't handle case of prefixFwd = 0 correctly
                    let prefixFwd = longestPrefixFwd (dp.Forward.Primer.Length)
                    //printf "CM primer fwd prefixFwd=%A prefix = %s\n" prefixFwd (dp.fwd.Primer.[..(prefixFwd/1<ZeroOffset>)-1] |> arr2seq)

                    sprintf @"
                                <PRIMER name=""PF"">
                                <VERSION>0</VERSION>
                                <SEQHOMOL>%s</SEQHOMOL>
                                <BINDSITE>%A,0,0,%d,0,%d</BINDSITE>
                                <DESCRIPTION>PF</DESCRIPTION></PRIMER>
                                " (dp.Forward.Primer.ToString())
                        //
                        // ............[XXXXXXXXXXX]...........
                        //              ttttttttttttbbbbbbbbbbb>> (tail/body)

                        ((p.DestinationTo
                          - (* (dp.fwd.tail.Length-1)*1<ZeroOffset> *) prefixFwd
                          + 1<ZeroOffset>)
                         |> ZeroOffset.toOne) dp.Forward.Primer.Length dp.Forward.Primer.Length
                    |> w

        sprintf @"
            <SEQUENCE>%s</SEQUENCE>
            </MOLECULE>" totSequence.str
        |> w
